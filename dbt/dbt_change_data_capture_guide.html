<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dbt Change Data Capture (CDC): Complete Implementation Guide</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #2980b9;
            margin-top: 30px;
        }
        h3 {
            color: #34495e;
            margin-top: 25px;
        }
        .code-block {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            overflow-x: auto;
            margin: 15px 0;
        }
        .warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-left: 4px solid #f39c12;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        ul, ol {
            padding-left: 30px;
        }
        li {
            margin-bottom: 5px;
        }
        .toc {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc ul li {
            margin-bottom: 8px;
        }
        .toc a {
            text-decoration: none;
            color: #495057;
        }
        .toc a:hover {
            color: #007bff;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        .comparison-table {
            margin: 20px 0;
        }
        .comparison-table th {
            background-color: #3498db;
            color: white;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>dbt Change Data Capture (CDC): Complete Implementation Guide</h1>
        
        <p>This comprehensive guide covers implementing Change Data Capture (CDC) patterns in dbt for tracking and processing data changes over time. Learn to build robust, efficient CDC solutions for real-time data synchronization and historical tracking.</p>

        <div class="toc">
            <h3>Table of Contents</h3>
            <ul>
                <li><a href="#introduction">1. Introduction to CDC in dbt</a></li>
                <li><a href="#cdc-vs-materialization">2. CDC vs dbt Materialization Strategies</a></li>
                <li><a href="#fundamentals">3. CDC Fundamentals</a></li>
                <li><a href="#cdc-patterns">4. CDC Implementation Patterns</a></li>
                <li><a href="#timestamp-based">5. Timestamp-Based CDC</a></li>
                <li><a href="#log-based">6. Log-Based CDC</a></li>
                <li><a href="#trigger-based">7. Trigger-Based CDC</a></li>
                <li><a href="#snapshot-comparison">8. Snapshot Comparison CDC</a></li>
                <li><a href="#scd-integration">9. SCD Integration with CDC</a></li>
                <li><a href="#real-time">10. Real-Time CDC Processing</a></li>
                <li><a href="#performance">11. Performance Optimization</a></li>
                <li><a href="#monitoring">12. Monitoring and Alerting</a></li>
                <li><a href="#troubleshooting">13. Troubleshooting Guide</a></li>
                <li><a href="#code-examples">14. Code Examples</a></li>
                <li><a href="#best-practices">15. Best Practices</a></li>
                <li><a href="#advanced-patterns">16. Advanced Patterns</a></li>
            </ul>
        </div>

        <h2 id="introduction">1. Introduction to CDC in dbt</h2>
        
        <p>Change Data Capture (CDC) is a pattern used to identify and track changes in data over time. In dbt, CDC enables efficient data synchronization, historical tracking, and real-time analytics by processing only changed records rather than entire datasets.</p>

        <div class="info">
            <strong>Key Benefits:</strong>
            <ul>
                <li><strong>Efficiency:</strong> Process only changed data, reducing compute costs</li>
                <li><strong>Real-time Analytics:</strong> Enable near-real-time data processing</li>
                <li><strong>Data Lineage:</strong> Maintain complete audit trails</li>
                <li><strong>Conflict Resolution:</strong> Handle concurrent updates gracefully</li>
            </ul>
        </div>

        <h2 id="cdc-vs-materialization">2. CDC vs dbt Materialization Strategies</h2>
        
        <p>It's crucial to understand the distinction between <strong>Change Data Capture (CDC)</strong> as a data integration pattern and <strong>dbt's incremental materialization strategies</strong> like "merge". While they work together, they serve different purposes:</p>

        <h3>2.1 Change Data Capture (CDC) - Data Integration Pattern</h3>
        <div class="info">
            <p><strong>CDC is a data integration pattern</strong> focused on identifying, capturing, and processing data changes from source systems:</p>
            <ul>
                <li><strong>Purpose:</strong> Capture and identify what data has changed in source systems</li>
                <li><strong>Scope:</strong> Handles change detection, ordering, and metadata enrichment</li>
                <li><strong>Methods:</strong> Timestamp-based, log-based, trigger-based, snapshot comparison</li>
                <li><strong>Output:</strong> Enriched change records with operation types (INSERT, UPDATE, DELETE)</li>
                <li><strong>Business Value:</strong> Enables real-time data synchronization and audit trails</li>
            </ul>
        </div>

        <h3>2.2 dbt Materialization Strategies - Data Processing Method</h3>
        <div class="warning">
            <p><strong>dbt materialization strategies</strong> determine how dbt physically applies changes to target tables:</p>
            <ul>
                <li><strong>Purpose:</strong> Define how dbt writes data to the data warehouse</li>
                <li><strong>Scope:</strong> Controls SQL operations for building/updating tables</li>
                <li><strong>Strategies:</strong> append, merge, delete+insert, insert_overwrite</li>
                <li><strong>Output:</strong> Updated target tables in the data warehouse</li>
                <li><strong>Technical Focus:</strong> Optimizes warehouse operations and performance</li>
            </ul>
        </div>

        <h3>2.3 How They Work Together</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>CDC Pattern</th>
                    <th>dbt Materialization</th>
                    <th>Combined Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Data Source</strong></td>
                    <td>Captures changes from OLTP systems</td>
                    <td>Processes data from staging tables</td>
                    <td>CDC captures database logs ‚Üí dbt processes with merge strategy</td>
                </tr>
                <tr>
                    <td><strong>Change Detection</strong></td>
                    <td>Identifies what changed and when</td>
                    <td>Uses CDC output to determine actions</td>
                    <td>CDC identifies updated orders ‚Üí merge strategy updates dimension table</td>
                </tr>
                <tr>
                    <td><strong>Metadata Handling</strong></td>
                    <td>Adds operation types, timestamps, sequences</td>
                    <td>Uses metadata for conditional logic</td>
                    <td>CDC adds _operation_type ‚Üí merge uses it for INSERT/UPDATE/DELETE</td>
                </tr>
                <tr>
                    <td><strong>Performance</strong></td>
                    <td>Reduces data volume by filtering changes</td>
                    <td>Optimizes warehouse operations</td>
                    <td>CDC processes 1000 changed records ‚Üí merge updates only those rows</td>
                </tr>
            </tbody>
        </table>

        <h3>2.4 Practical Example: CDC + Merge Strategy</h3>
        <div class="code-block">
-- Step 1: CDC Pattern captures changes from source
-- models/staging/stg_customers_cdc.sql
WITH cdc_changes AS (
    SELECT 
        customer_id,
        customer_name,
        email,
        updated_at,
        _operation_type, -- CDC metadata: INSERT, UPDATE, DELETE
        _sequence_number -- CDC ordering
    FROM {{ source('cdc_logs', 'customer_changes') }}
    WHERE updated_at > '{{ var("last_processed_timestamp") }}'
),

-- Step 2: dbt Merge Strategy applies changes to target
-- models/marts/dim_customers.sql
{{
    config(
        materialized='incremental',
        incremental_strategy='merge',  -- dbt materialization strategy
        unique_key='customer_id'
    )
}}

SELECT 
    customer_id,
    customer_name,
    email,
    updated_at,
    CASE 
        WHEN _operation_type = 'DELETE' THEN TRUE 
        ELSE FALSE 
    END as is_deleted
FROM {{ ref('stg_customers_cdc') }}

-- The merge strategy will:
-- - INSERT new customer_ids
-- - UPDATE existing customer_ids  
-- - Handle DELETEs based on CDC metadata
        </div>

        <h3>2.5 Key Distinctions Summary</h3>
        <div class="success">
            <p><strong>Think of it this way:</strong></p>
            <ul>
                <li><strong>CDC answers:</strong> "What changed in my source systems and when?"</li>
                <li><strong>Materialization strategies answer:</strong> "How should dbt apply these changes to my warehouse?"</li>
                <li><strong>CDC is the input pattern</strong> that identifies and enriches change data</li>
                <li><strong>Materialization is the output method</strong> that applies changes efficiently</li>
                <li><strong>You use both together:</strong> CDC to capture changes + appropriate materialization strategy to apply them</li>
            </ul>
        </div>

        <div class="warning">
            <h4>Common Misconception:</h4>
            <p>The "merge" incremental strategy is <strong>not</strong> CDC itself. It's a SQL operation (MERGE statement) that dbt uses to apply changes. CDC is the broader pattern of identifying and processing those changes in the first place.</p>
        </div>

        <h2 id="fundamentals">3. CDC Fundamentals</h2>

        <h3>3.1 CDC Types</h3>
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>CDC Type</th>
                    <th>Description</th>
                    <th>Use Case</th>
                    <th>Complexity</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Timestamp-Based</td>
                    <td>Uses modification timestamps</td>
                    <td>Simple incremental loads</td>
                    <td>Low</td>
                </tr>
                <tr>
                    <td>Log-Based</td>
                    <td>Reads database transaction logs</td>
                    <td>Real-time replication</td>
                    <td>High</td>
                </tr>
                <tr>
                    <td>Trigger-Based</td>
                    <td>Database triggers capture changes</td>
                    <td>Detailed audit trails</td>
                    <td>Medium</td>
                </tr>
                <tr>
                    <td>Snapshot Comparison</td>
                    <td>Compares full snapshots</td>
                    <td>Batch processing</td>
                    <td>Medium</td>
                </tr>
            </tbody>
        </table>

        <h3>3.2 CDC Architecture in dbt</h3>
        <div class="code-block">
-- CDC Architecture Components
Source System ‚Üí CDC Capture ‚Üí Staging Area ‚Üí dbt Processing ‚Üí Target Tables
     ‚Üì              ‚Üì             ‚Üì              ‚Üì              ‚Üì
  Operational   Change Log    Raw Changes   Transformed    Final Data
   Database     Extraction     Staging       Changes        Warehouse
        </div>

        <h2 id="cdc-patterns">4. CDC Implementation Patterns</h2>

        <h3>4.1 Incremental Model Pattern</h3>
        <div class="code-block">
-- models/staging/stg_orders_cdc.sql
{{
    config(
        materialized='incremental',
        unique_key='order_id',
        on_schema_change='sync_all_columns'
    )
}}

WITH source_data AS (
    SELECT 
        order_id,
        customer_id,
        order_status,
        order_date,
        updated_at,
        _operation_type,
        _sequence_number
    FROM {{ ref('raw_orders_cdc') }}
    
    {% if is_incremental() %}
        WHERE updated_at > (SELECT MAX(updated_at) FROM {{ this }})
    {% endif %}
),

-- Deduplicate based on sequence number (latest change wins)
deduplicated AS (
    SELECT *,
        ROW_NUMBER() OVER (
            PARTITION BY order_id 
            ORDER BY _sequence_number DESC
        ) as rn
    FROM source_data
)

SELECT *
FROM deduplicated
WHERE rn = 1
        </div>

        <h3>4.2 SCD Type 2 with CDC</h3>
        <div class="code-block">
-- models/marts/dim_customer_scd2.sql
{{
    config(
        materialized='incremental',
        unique_key='surrogate_key'
    )
}}

WITH source_changes AS (
    SELECT 
        customer_id,
        customer_name,
        email,
        address,
        phone,
        updated_at,
        _operation_type,
        _sequence_number
    FROM {{ ref('stg_customers_cdc') }}
    
    {% if is_incremental() %}
        WHERE updated_at > (SELECT MAX(effective_end_date) FROM {{ this }} WHERE effective_end_date IS NOT NULL)
           OR updated_at > (SELECT MAX(effective_start_date) FROM {{ this }} WHERE effective_end_date IS NULL)
    {% endif %}
),

-- Generate surrogate keys and validity periods
scd_logic AS (
    SELECT 
        {{ dbt_utils.generate_surrogate_key(['customer_id', 'updated_at']) }} as surrogate_key,
        customer_id,
        customer_name,
        email,
        address,
        phone,
        updated_at as effective_start_date,
        CASE 
            WHEN _operation_type = 'DELETE' THEN updated_at
            ELSE NULL 
        END as effective_end_date,
        _operation_type,
        CASE WHEN _operation_type = 'DELETE' THEN FALSE ELSE TRUE END as is_current
    FROM source_changes
)

SELECT * FROM scd_logic
        </div>

        <h2 id="timestamp-based">5. Timestamp-Based CDC</h2>

        <h3>5.1 Basic Timestamp CDC</h3>
        <div class="code-block">
-- models/staging/stg_products_timestamp_cdc.sql
{{
    config(
        materialized='incremental',
        unique_key='product_id'
    )
}}

SELECT 
    product_id,
    product_name,
    category_id,
    price,
    created_at,
    updated_at,
    -- Add CDC metadata
    CURRENT_TIMESTAMP as processed_at,
    'UPSERT' as cdc_operation
FROM {{ source('ecommerce', 'products') }}

{% if is_incremental() %}
    -- Only process records updated since last run
    WHERE updated_at > (
        SELECT COALESCE(MAX(updated_at), '1900-01-01'::timestamp) 
        FROM {{ this }}
    )
{% endif %}
        </div>

        <h3>5.2 Advanced Timestamp CDC with Deletes</h3>
        <div class="code-block">
-- models/staging/stg_customers_advanced_cdc.sql
{{
    config(
        materialized='incremental',
        unique_key='customer_id'
    )
}}

WITH current_data AS (
    SELECT 
        customer_id,
        customer_name,
        email,
        status,
        updated_at,
        FALSE as is_deleted
    FROM {{ source('crm', 'customers') }}
    WHERE status != 'DELETED'
    
    {% if is_incremental() %}
        AND updated_at > (
            SELECT COALESCE(MAX(updated_at), '1900-01-01'::timestamp) 
            FROM {{ this }}
            WHERE NOT is_deleted
        )
    {% endif %}
),

deleted_data AS (
    SELECT 
        customer_id,
        customer_name,
        email,
        status,
        updated_at,
        TRUE as is_deleted
    FROM {{ source('crm', 'customers') }}
    WHERE status = 'DELETED'
    
    {% if is_incremental() %}
        AND updated_at > (
            SELECT COALESCE(MAX(updated_at), '1900-01-01'::timestamp) 
            FROM {{ this }}
            WHERE is_deleted
        )
    {% endif %}
)

SELECT * FROM current_data
UNION ALL
SELECT * FROM deleted_data
        </div>

        <h2 id="log-based">6. Log-Based CDC</h2>

        <h3>6.1 Processing WAL/Binlog Data</h3>
        <div class="code-block">
-- models/staging/stg_orders_log_based_cdc.sql
{{
    config(
        materialized='incremental',
        unique_key=['order_id', 'log_sequence_number']
    )
}}

WITH log_entries AS (
    SELECT 
        -- Parse log entry data
        JSON_EXTRACT_SCALAR(log_data, '$.order_id') as order_id,
        JSON_EXTRACT_SCALAR(log_data, '$.customer_id') as customer_id,
        JSON_EXTRACT_SCALAR(log_data, '$.order_status') as order_status,
        JSON_EXTRACT_SCALAR(log_data, '$.total_amount') as total_amount,
        
        -- CDC metadata from log
        operation_type, -- INSERT, UPDATE, DELETE
        log_sequence_number,
        transaction_id,
        commit_timestamp,
        
        -- Row change metadata
        CASE operation_type
            WHEN 'UPDATE' THEN JSON_EXTRACT(log_data, '$.before')
            ELSE NULL
        END as before_values,
        
        CASE operation_type
            WHEN 'DELETE' THEN JSON_EXTRACT(log_data, '$.before')
            ELSE JSON_EXTRACT(log_data, '$.after')
        END as after_values
        
    FROM {{ source('cdc_logs', 'order_changes') }}
    
    {% if is_incremental() %}
        WHERE log_sequence_number > (
            SELECT COALESCE(MAX(log_sequence_number), 0) 
            FROM {{ this }}
        )
    {% endif %}
),

-- Process changes with conflict resolution
processed_changes AS (
    SELECT 
        *,
        -- Determine final operation after deduplication
        LAST_VALUE(operation_type) OVER (
            PARTITION BY order_id 
            ORDER BY log_sequence_number 
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) as final_operation,
        
        -- Mark as latest change for this key
        ROW_NUMBER() OVER (
            PARTITION BY order_id 
            ORDER BY log_sequence_number DESC
        ) = 1 as is_latest_change
        
    FROM log_entries
)

SELECT * FROM processed_changes
        </div>

        <h3>6.2 Log-Based CDC Deduplication</h3>
        <div class="code-block">
-- models/marts/fct_orders_current_state.sql
-- Reconstruct current state from log entries

WITH latest_operations AS (
    SELECT 
        order_id,
        customer_id,
        order_status,
        total_amount,
        final_operation,
        commit_timestamp,
        
        -- Only keep the final state per order
        ROW_NUMBER() OVER (
            PARTITION BY order_id 
            ORDER BY log_sequence_number DESC
        ) = 1 as is_current_state
        
    FROM {{ ref('stg_orders_log_based_cdc') }}
    WHERE is_latest_change
),

current_orders AS (
    SELECT 
        order_id,
        customer_id,
        order_status,
        total_amount,
        commit_timestamp as last_updated_at
    FROM latest_operations
    WHERE is_current_state 
      AND final_operation != 'DELETE' -- Exclude deleted records
)

SELECT * FROM current_orders
        </div>

        <h2 id="trigger-based">7. Trigger-Based CDC</h2>

        <h3>7.1 Processing Audit Table Data</h3>
        <div class="code-block">
-- models/staging/stg_inventory_audit_cdc.sql
{{
    config(
        materialized='incremental',
        unique_key='audit_id'
    )
}}

WITH audit_changes AS (
    SELECT 
        audit_id,
        table_name,
        operation_type, -- I, U, D
        primary_key_value,
        changed_columns,
        old_values,
        new_values,
        changed_by,
        changed_at,
        
        -- Parse the changed data
        CASE 
            WHEN operation_type = 'I' THEN new_values
            WHEN operation_type = 'D' THEN old_values  
            ELSE new_values
        END as current_values
        
    FROM {{ source('audit', 'inventory_audit') }}
    WHERE table_name = 'inventory'
    
    {% if is_incremental() %}
        AND changed_at > (
            SELECT COALESCE(MAX(changed_at), '1900-01-01'::timestamp)
            FROM {{ this }}
        )
    {% endif %}
),

-- Extract inventory fields from JSON values
parsed_inventory AS (
    SELECT 
        audit_id,
        primary_key_value::INTEGER as inventory_id,
        operation_type,
        changed_by,
        changed_at,
        
        -- Extract fields from JSON
        JSON_EXTRACT_SCALAR(current_values, '$.product_id')::INTEGER as product_id,
        JSON_EXTRACT_SCALAR(current_values, '$.quantity_on_hand')::INTEGER as quantity_on_hand,
        JSON_EXTRACT_SCALAR(current_values, '$.reserved_quantity')::INTEGER as reserved_quantity,
        JSON_EXTRACT_SCALAR(current_values, '$.location_code') as location_code,
        
        -- Track what changed
        changed_columns
        
    FROM audit_changes
)

SELECT * FROM parsed_inventory
        </div>

        <h2 id="snapshot-comparison">8. Snapshot Comparison CDC</h2>

        <h3>8.1 Full Snapshot Comparison</h3>
        <div class="code-block">
-- models/staging/stg_suppliers_snapshot_cdc.sql
{{
    config(
        materialized='incremental',
        unique_key='supplier_id'
    )
}}

{% if is_incremental() %}

WITH current_snapshot AS (
    SELECT 
        supplier_id,
        supplier_name,
        contact_email,
        phone_number,
        address,
        credit_rating,
        CURRENT_DATE as snapshot_date,
        {{ dbt_utils.generate_surrogate_key([
            'supplier_name', 'contact_email', 'phone_number', 
            'address', 'credit_rating'
        ]) }} as content_hash
    FROM {{ source('procurement', 'suppliers') }}
),

previous_snapshot AS (
    SELECT 
        supplier_id,
        content_hash as previous_content_hash
    FROM {{ this }}
    WHERE snapshot_date = (SELECT MAX(snapshot_date) FROM {{ this }})
),

-- Identify changes
changes AS (
    SELECT 
        c.*,
        p.previous_content_hash,
        CASE 
            WHEN p.supplier_id IS NULL THEN 'INSERT'
            WHEN c.content_hash != p.previous_content_hash THEN 'UPDATE'
            ELSE 'NO_CHANGE'
        END as change_type
    FROM current_snapshot c
    LEFT JOIN previous_snapshot p ON c.supplier_id = p.supplier_id
),

-- Also identify deletes
deletes AS (
    SELECT 
        p.supplier_id,
        NULL as supplier_name,
        NULL as contact_email,
        NULL as phone_number,
        NULL as address,
        NULL as credit_rating,
        CURRENT_DATE as snapshot_date,
        NULL as content_hash,
        NULL as previous_content_hash,
        'DELETE' as change_type
    FROM previous_snapshot p
    LEFT JOIN current_snapshot c ON p.supplier_id = c.supplier_id
    WHERE c.supplier_id IS NULL
)

SELECT * FROM changes
WHERE change_type != 'NO_CHANGE'

UNION ALL

SELECT * FROM deletes

{% else %}
-- Initial load
SELECT 
    supplier_id,
    supplier_name,
    contact_email,
    phone_number,
    address,
    credit_rating,
    CURRENT_DATE as snapshot_date,
    {{ dbt_utils.generate_surrogate_key([
        'supplier_name', 'contact_email', 'phone_number', 
        'address', 'credit_rating'
    ]) }} as content_hash,
    NULL as previous_content_hash,
    'INITIAL_LOAD' as change_type
FROM {{ source('procurement', 'suppliers') }}

{% endif %}
        </div>

        <h2 id="scd-integration">9. SCD Integration with CDC</h2>

        <h3>9.1 SCD Type 2 with CDC Processing</h3>
        <div class="code-block">
-- models/marts/dim_product_scd2_cdc.sql
{{
    config(
        materialized='incremental',
        unique_key='surrogate_key',
        on_schema_change='sync_all_columns'
    )
}}

WITH cdc_changes AS (
    SELECT *
    FROM {{ ref('stg_products_timestamp_cdc') }}
    
    {% if is_incremental() %}
        WHERE processed_at > (
            SELECT COALESCE(MAX(processed_at), '1900-01-01'::timestamp)
            FROM {{ this }}
        )
    {% endif %}
),

-- Get current active records for comparison
{% if is_incremental() %}
current_active AS (
    SELECT *
    FROM {{ this }}
    WHERE is_current = TRUE
),
{% endif %}

-- Process Type 2 changes
scd_processing AS (
    SELECT 
        {{ dbt_utils.generate_surrogate_key(['product_id', 'updated_at']) }} as surrogate_key,
        product_id,
        product_name,
        category_id,
        price,
        updated_at as effective_start_date,
        NULL as effective_end_date,
        TRUE as is_current,
        cdc_operation,
        processed_at
    FROM cdc_changes
    WHERE cdc_operation != 'DELETE'
),

-- Handle record expiration for updates
{% if is_incremental() %}
expired_records AS (
    SELECT 
        c.surrogate_key,
        c.product_id,
        c.product_name,
        c.category_id, 
        c.price,
        c.effective_start_date,
        cc.updated_at as effective_end_date, -- Close the record
        FALSE as is_current,
        c.cdc_operation,
        c.processed_at
    FROM current_active c
    INNER JOIN cdc_changes cc ON c.product_id = cc.product_id
    WHERE cc.cdc_operation IN ('UPDATE', 'DELETE')
),
{% endif %}

-- Combine all changes
final_changes AS (
    SELECT * FROM scd_processing
    
    {% if is_incremental() %}
    UNION ALL
    SELECT * FROM expired_records
    {% endif %}
)

SELECT * FROM final_changes
        </div>

        <h2 id="real-time">10. Real-Time CDC Processing</h2>

        <h3>10.1 Micro-Batch Processing</h3>
        <div class="code-block">
-- models/staging/stg_events_microbatch_cdc.sql
{{
    config(
        materialized='incremental',
        incremental_strategy='microbatch',
        event_time='event_timestamp',
        batch_size='hour',
        unique_key='event_id'
    )
}}

WITH event_stream AS (
    SELECT 
        event_id,
        user_id,
        event_type,
        event_data,
        event_timestamp,
        ingested_at,
        
        -- Add microbatch processing metadata
        DATE_TRUNC('hour', event_timestamp) as batch_hour,
        LAG(event_timestamp) OVER (
            PARTITION BY user_id 
            ORDER BY event_timestamp
        ) as previous_event_time
        
    FROM {{ source('events', 'user_events') }}
    WHERE event_timestamp >= '{{ var("start_time") }}'
      AND event_timestamp < '{{ var("end_time") }}'
),

-- Process changes within the microbatch
processed_events AS (
    SELECT 
        *,
        -- Calculate time between events
        COALESCE(
            EXTRACT(EPOCH FROM (event_timestamp - previous_event_time))/60,
            0
        ) as minutes_since_last_event,
        
        -- Detect session boundaries
        CASE 
            WHEN previous_event_time IS NULL THEN 'SESSION_START'
            WHEN EXTRACT(EPOCH FROM (event_timestamp - previous_event_time)) > 1800 THEN 'SESSION_START'
            ELSE 'SESSION_CONTINUE'
        END as session_indicator
        
    FROM event_stream
)

SELECT * FROM processed_events
        </div>

        <h3>10.2 Real-Time Aggregation with CDC</h3>
        <div class="code-block">
-- models/marts/fct_user_activity_realtime.sql
{{
    config(
        materialized='incremental',
        unique_key=['user_id', 'activity_hour'],
        on_schema_change='sync_all_columns'
    )
}}

WITH hourly_activity AS (
    SELECT 
        user_id,
        DATE_TRUNC('hour', event_timestamp) as activity_hour,
        COUNT(*) as event_count,
        COUNT(DISTINCT event_type) as unique_event_types,
        MIN(event_timestamp) as first_event_time,
        MAX(event_timestamp) as last_event_time,
        
        -- Session metrics
        COUNT(CASE WHEN session_indicator = 'SESSION_START' THEN 1 END) as new_sessions,
        SUM(CASE WHEN event_type = 'purchase' THEN 1 ELSE 0 END) as purchase_events,
        
        -- Real-time processing metadata
        MAX(ingested_at) as last_processed_at,
        CURRENT_TIMESTAMP as aggregation_timestamp
        
    FROM {{ ref('stg_events_microbatch_cdc') }}
    
    {% if is_incremental() %}
        WHERE activity_hour > (
            SELECT COALESCE(MAX(activity_hour), '1900-01-01'::timestamp)
            FROM {{ this }}
        )
    {% endif %}
    
    GROUP BY user_id, activity_hour
)

SELECT * FROM hourly_activity
        </div>

        <h2 id="performance">11. Performance Optimization</h2>

        <h3>11.1 Partition-Based CDC Processing</h3>
        <div class="code-block">
-- models/staging/stg_transactions_partitioned_cdc.sql
{{
    config(
        materialized='incremental',
        unique_key='transaction_id',
        partition_by={
            'field': 'transaction_date',
            'data_type': 'date',
            'granularity': 'day'
        },
        cluster_by=['account_id', 'transaction_type']
    )
}}

WITH partitioned_source AS (
    SELECT 
        transaction_id,
        account_id,
        transaction_type,
        amount,
        currency,
        transaction_timestamp,
        DATE(transaction_timestamp) as transaction_date,
        updated_at,
        
        -- Partition metadata for optimization
        DATE_TRUNC('month', transaction_timestamp) as partition_month
        
    FROM {{ source('banking', 'transactions') }}
    
    {% if is_incremental() %}
        -- Leverage partition pruning
        WHERE DATE(transaction_timestamp) >= CURRENT_DATE - INTERVAL '7 days'
          AND updated_at > (
              SELECT COALESCE(MAX(updated_at), '1900-01-01'::timestamp)
              FROM {{ this }}
              WHERE transaction_date >= CURRENT_DATE - INTERVAL '7 days'
          )
    {% endif %}
),

-- Add processing optimizations
optimized_processing AS (
    SELECT 
        *,
        -- Pre-calculate common aggregation keys
        {{ dbt_utils.generate_surrogate_key(['account_id', 'transaction_date']) }} as daily_account_key,
        
        -- Add change detection hash for efficiency
        {{ dbt_utils.generate_surrogate_key([
            'amount', 'currency', 'transaction_type'
        ]) }} as transaction_content_hash
        
    FROM partitioned_source
)

SELECT * FROM optimized_processing
        </div>

        <h3>11.2 Incremental Strategy Optimization</h3>
        <div class="code-block">
-- macros/optimize_cdc_merge.sql
{% macro optimize_cdc_merge(target_relation, temp_relation, unique_key, dest_columns) %}

    {% set merge_sql %}
        MERGE {{ target_relation }} as target
        USING (
            SELECT * FROM {{ temp_relation }}
        ) as source
        ON {{ unique_key_to_sql(unique_key, 'target', 'source') }}
        
        WHEN MATCHED AND (
            -- Only update if content actually changed
            target.content_hash != source.content_hash OR
            target.updated_at < source.updated_at
        ) THEN
            UPDATE SET
            {% for column in dest_columns -%}
                {{ column.name }} = source.{{ column.name }}
                {%- if not loop.last -%},{%- endif %}
            {%- endfor %}
        
        WHEN NOT MATCHED THEN
            INSERT (
                {%- for column in dest_columns -%}
                    {{ column.name }}
                    {%- if not loop.last -%},{%- endif %}
                {%- endfor -%}
            )
            VALUES (
                {%- for column in dest_columns -%}
                    source.{{ column.name }}
                    {%- if not loop.last -%},{%- endif %}
                {%- endfor -%}
            )
        
        WHEN MATCHED AND source._operation_type = 'DELETE' THEN
            DELETE
    {% endset %}

    {{ return(merge_sql) }}

{% endmacro %}
        </div>

        <h2 id="monitoring">12. Monitoring and Alerting</h2>

        <h3>12.1 CDC Processing Metrics</h3>
        <div class="code-block">
-- models/monitoring/cdc_processing_metrics.sql
WITH cdc_runs AS (
    SELECT 
        model_name,
        run_started_at,
        run_completed_at,
        status,
        rows_affected,
        execution_time_seconds,
        
        -- Calculate processing lag
        EXTRACT(EPOCH FROM (
            run_completed_at - 
            (SELECT MAX(updated_at) FROM {{ ref('stg_source_table') }})
        ))/60 as processing_lag_minutes,
        
        -- Detect anomalies
        rows_affected - LAG(rows_affected, 1, 0) OVER (
            PARTITION BY model_name 
            ORDER BY run_started_at
        ) as row_change_from_previous,
        
        execution_time_seconds - LAG(execution_time_seconds, 1, 0) OVER (
            PARTITION BY model_name 
            ORDER BY run_started_at
        ) as execution_time_change
        
    FROM {{ source('dbt_metadata', 'model_runs') }}
    WHERE model_name LIKE '%_cdc'
),

metrics_summary AS (
    SELECT 
        model_name,
        run_completed_at,
        
        -- SLA metrics
        CASE 
            WHEN processing_lag_minutes > 30 THEN 'SLA_BREACH'
            WHEN processing_lag_minutes > 15 THEN 'SLA_WARNING' 
            ELSE 'SLA_OK'
        END as sla_status,
        
        -- Anomaly detection
        CASE
            WHEN ABS(row_change_from_previous) > (
                AVG(ABS(row_change_from_previous)) OVER (
                    PARTITION BY model_name 
                    ORDER BY run_started_at 
                    ROWS BETWEEN 10 PRECEDING AND 1 PRECEDING
                ) * 3
            ) THEN 'ANOMALY_DETECTED'
            ELSE 'NORMAL'
        END as volume_anomaly,
        
        processing_lag_minutes,
        execution_time_seconds,
        rows_affected
        
    FROM cdc_runs
    WHERE run_completed_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
)

SELECT * FROM metrics_summary
        </div>

        <h3>12.2 Data Quality Monitoring for CDC</h3>
        <div class="code-block">
-- tests/generic/test_cdc_data_quality.sql
-- Test for CDC data quality issues

SELECT 
    'duplicate_keys' as test_type,
    COUNT(*) as failure_count,
    'Found duplicate keys in CDC processing' as error_message
FROM (
    SELECT {{ unique_key }}
    FROM {{ ref(model) }}
    WHERE {{ partition_filter if partition_filter else '1=1' }}
    GROUP BY {{ unique_key }}
    HAVING COUNT(*) > 1
)

UNION ALL

SELECT 
    'missing_timestamps' as test_type,
    COUNT(*) as failure_count,
    'Found records with missing CDC timestamps' as error_message
FROM {{ ref(model) }}
WHERE updated_at IS NULL
  AND {{ partition_filter if partition_filter else '1=1' }}

UNION ALL

SELECT 
    'future_timestamps' as test_type,
    COUNT(*) as failure_count,
    'Found records with future timestamps' as error_message
FROM {{ ref(model) }}
WHERE updated_at > CURRENT_TIMESTAMP + INTERVAL '1 hour'
  AND {{ partition_filter if partition_filter else '1=1' }}

UNION ALL

SELECT 
    'sequence_gaps' as test_type,
    COUNT(*) as failure_count,
    'Found gaps in sequence numbers' as error_message
FROM (
    SELECT 
        sequence_number,
        LAG(sequence_number) OVER (ORDER BY sequence_number) as prev_seq
    FROM {{ ref(model) }}
    WHERE {{ partition_filter if partition_filter else '1=1' }}
) 
WHERE sequence_number - prev_seq > 1
        </div>

        <h2 id="troubleshooting">13. Troubleshooting Guide</h2>

        <div class="warning">
            <h3>Common CDC Issues and Solutions</h3>
            
            <h4>1. Missing Changes</h4>
            <ul>
                <li><strong>Cause:</strong> Incorrect timestamp filtering or timezone issues</li>
                <li><strong>Solution:</strong> Ensure consistent timezone handling and inclusive time ranges</li>
                <li><strong>Prevention:</strong> Use UTC timestamps and add buffer time to filters</li>
            </ul>
            
            <h4>2. Duplicate Processing</h4>
            <ul>
                <li><strong>Cause:</strong> Non-deterministic incremental logic or concurrent runs</li>
                <li><strong>Solution:</strong> Implement proper deduplication and run locks</li>
                <li><strong>Prevention:</strong> Use unique keys and sequence numbers</li>
            </ul>
            
            <h4>3. Performance Degradation</h4>
            <ul>
                <li><strong>Cause:</strong> Large incremental windows or missing indexes</li>
                <li><strong>Solution:</strong> Optimize partition strategy and add appropriate indexes</li>
                <li><strong>Prevention:</strong> Monitor processing volumes and execution times</li>
            </ul>
            
            <h4>4. Data Consistency Issues</h4>
            <ul>
                <li><strong>Cause:</strong> Out-of-order processing or incomplete transactions</li>
                <li><strong>Solution:</strong> Implement proper ordering and transaction boundaries</li>
                <li><strong>Prevention:</strong> Use sequence numbers and transaction IDs</li>
            </ul>
        </div>

        <h2 id="code-examples">14. Code Examples</h2>
        
        <p>For detailed implementation examples and ready-to-use code templates, see the comprehensive code examples in the repository:</p>
        
        <div class="success">
            <h3>üìÅ Code Examples Repository</h3>
            <p>Access all CDC implementation examples and templates:</p>
            <ul>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/01_timestamp_based_cdc.sql">Timestamp-Based CDC Implementation</a></li>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/02_log_based_cdc.sql">Log-Based CDC Processing</a></li>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/03_trigger_based_cdc.sql">Trigger-Based CDC Implementation</a></li>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/04_snapshot_comparison_cdc.sql">Snapshot Comparison CDC</a></li>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/05_scd_integration.sql">SCD Type 2 with CDC</a></li>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/06_real_time_processing.sql">Real-Time CDC Processing</a></li>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/07_performance_optimization.sql">Performance Optimization Patterns</a></li>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/08_monitoring_and_alerting.sql">Monitoring and Alerting Setup</a></li>
                <li><a href="https://github.com/konradKolenda/konradKolenda.github.io/blob/main/dbt/code_examples/dbt_change_data_capture_guide/README.md">Complete Setup Guide and Documentation</a></li>
            </ul>
        </div>

        <h2 id="best-practices">15. Best Practices</h2>

        <h3>15.1 Design Principles</h3>
        <div class="info">
            <ul>
                <li><strong>Idempotency:</strong> Ensure CDC processes can be safely re-run</li>
                <li><strong>Monotonic Processing:</strong> Process changes in chronological order</li>
                <li><strong>Complete Transactions:</strong> Handle transaction boundaries properly</li>
                <li><strong>Schema Evolution:</strong> Plan for source schema changes</li>
                <li><strong>Error Handling:</strong> Implement robust error recovery mechanisms</li>
            </ul>
        </div>

        <h3>15.2 Implementation Guidelines</h3>
        <div class="code-block">
-- CDC Best Practices Checklist
1. ‚úÖ Use unique keys for deduplication
2. ‚úÖ Implement proper timestamp handling (UTC)  
3. ‚úÖ Add sequence numbers for ordering
4. ‚úÖ Include operation type metadata
5. ‚úÖ Handle deletes explicitly
6. ‚úÖ Monitor processing lag and volumes
7. ‚úÖ Test with edge cases (late arrivals, duplicates)
8. ‚úÖ Document data lineage and dependencies
9. ‚úÖ Implement circuit breakers for large volumes
10. ‚úÖ Plan for disaster recovery scenarios
        </div>

        <h3>15.3 Production Readiness</h3>
        <table>
            <thead>
                <tr>
                    <th>Category</th>
                    <th>Requirement</th>
                    <th>Implementation</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Monitoring</td>
                    <td>Processing lag alerts</td>
                    <td>SLA-based alerting on processing delays</td>
                </tr>
                <tr>
                    <td>Data Quality</td>
                    <td>Automated testing</td>
                    <td>dbt tests for duplicates, gaps, consistency</td>
                </tr>
                <tr>
                    <td>Performance</td>
                    <td>Scalable architecture</td>
                    <td>Partitioning, clustering, micro-batches</td>
                </tr>
                <tr>
                    <td>Recovery</td>
                    <td>Backfill capability</td>
                    <td>Historical reprocessing workflows</td>
                </tr>
                <tr>
                    <td>Documentation</td>
                    <td>Operational runbooks</td>
                    <td>Troubleshooting guides and escalation</td>
                </tr>
            </tbody>
        </table>

        <h2 id="advanced-patterns">16. Advanced Patterns</h2>

        <h3>16.1 Multi-Source CDC Federation</h3>
        <div class="code-block">
-- models/staging/stg_customer_360_cdc.sql
-- Federate CDC from multiple customer data sources

WITH crm_changes AS (
    SELECT 
        'CRM' as source_system,
        customer_id,
        email,
        phone,
        NULL as billing_address,
        updated_at,
        _operation_type
    FROM {{ ref('stg_crm_customers_cdc') }}
),

billing_changes AS (
    SELECT 
        'BILLING' as source_system,
        customer_id,
        NULL as email,
        NULL as phone, 
        billing_address,
        updated_at,
        _operation_type
    FROM {{ ref('stg_billing_customers_cdc') }}
),

-- Merge and resolve conflicts
federated_changes AS (
    SELECT * FROM crm_changes
    UNION ALL
    SELECT * FROM billing_changes
),

-- Apply precedence rules (CRM wins for contact info, Billing for address)
resolved_changes AS (
    SELECT 
        customer_id,
        FIRST_VALUE(email) OVER (
            PARTITION BY customer_id 
            ORDER BY CASE WHEN source_system = 'CRM' THEN 0 ELSE 1 END, updated_at DESC
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) as email,
        
        FIRST_VALUE(phone) OVER (
            PARTITION BY customer_id 
            ORDER BY CASE WHEN source_system = 'CRM' THEN 0 ELSE 1 END, updated_at DESC
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) as phone,
        
        FIRST_VALUE(billing_address) OVER (
            PARTITION BY customer_id 
            ORDER BY CASE WHEN source_system = 'BILLING' THEN 0 ELSE 1 END, updated_at DESC
            ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
        ) as billing_address,
        
        MAX(updated_at) as last_updated_at
        
    FROM federated_changes
    GROUP BY customer_id
)

SELECT * FROM resolved_changes
        </div>

        <h3>16.2 Event Sourcing with CDC</h3>
        <div class="code-block">
-- models/marts/customer_event_store.sql
-- Implement event sourcing pattern with CDC

{{
    config(
        materialized='incremental',
        unique_key='event_id',
        order_by='event_timestamp'
    )
}}

WITH source_events AS (
    SELECT 
        {{ dbt_utils.generate_surrogate_key(['customer_id', 'updated_at', 'source_system']) }} as event_id,
        customer_id,
        'CUSTOMER_UPDATED' as event_type,
        updated_at as event_timestamp,
        
        -- Event payload with before/after state
        JSON_BUILD_OBJECT(
            'before', JSON_BUILD_OBJECT(
                'email', LAG(email) OVER (PARTITION BY customer_id ORDER BY updated_at),
                'phone', LAG(phone) OVER (PARTITION BY customer_id ORDER BY updated_at),
                'status', LAG(status) OVER (PARTITION BY customer_id ORDER BY updated_at)
            ),
            'after', JSON_BUILD_OBJECT(
                'email', email,
                'phone', phone, 
                'status', status
            ),
            'source_system', source_system,
            'operation_type', _operation_type
        ) as event_payload,
        
        -- Event metadata
        source_system,
        _operation_type,
        ROW_NUMBER() OVER (ORDER BY updated_at) as global_sequence_number
        
    FROM {{ ref('stg_customer_360_cdc') }}
    
    {% if is_incremental() %}
        WHERE updated_at > (SELECT COALESCE(MAX(event_timestamp), '1900-01-01'::timestamp) FROM {{ this }})
    {% endif %}
)

SELECT * FROM source_events
        </div>

        <div class="success">
            <h3>üéØ Summary</h3>
            <p>This comprehensive guide provides everything needed to implement robust Change Data Capture patterns in dbt. From basic timestamp-based approaches to advanced event sourcing architectures, these patterns enable efficient, scalable data synchronization and historical tracking.</p>
            
            <p><strong>Key Takeaways:</strong></p>
            <ul>
                <li><strong>CDC vs Materialization:</strong> CDC identifies what changed (data pattern), materialization strategies control how to apply changes (SQL execution)</li>
                <li>Choose the appropriate CDC pattern based on your data sources and requirements</li>
                <li>Implement proper deduplication, ordering, and conflict resolution</li>
                <li>Monitor processing performance and data quality continuously</li>
                <li>Plan for schema evolution and operational complexities</li>
                <li>Test thoroughly with real-world scenarios and edge cases</li>
            </ul>
        </div>

        <hr>
        <p><strong>Official dbt Documentation:</strong> For the most up-to-date information on dbt incremental models and CDC patterns, visit <a href="https://docs.getdbt.com/docs/build/incremental-models">dbt Incremental Models</a> and <a href="https://docs.getdbt.com/docs/build/incremental-strategy">dbt Incremental Strategies</a>.</p>
    </div>
</body>
</html>